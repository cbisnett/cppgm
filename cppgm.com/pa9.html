<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<meta name="author" content="CPPGM" />
<meta name="description" content="C++ Grandmaster Certificaiton [CPPGM]" />
<meta name="keywords" content="c++" />
<title>C++ Grandmaster Certification [CPPGM]</title>
<link rel="stylesheet" type="text/css" href="css/style.css"
	media="screen" />
<link rel="shortcut icon" href="favicon.ico" />
<script src="js/jquery.min.js" type="text/javascript"></script>
<script type="text/javascript">
		
		function enrolled(data, textStatus, jqXHR)
		{
			alert("You have successfully enrolled in the course.");
		}
		
		function enroll_error(jqXHR, textStatus, errorThrown)
		{
			alert("An error occured while trying to enroll.  Please try again later. (" + textStatus + " : " + errorThrown + ")");	
		}
		
		function enroll(first_name, last_name, email_address)
		{
			if (first_name.length < 1)
				alert("Please fill in the First Name field.");
			else if (last_name.length < 1)
				alert("Please fill in the Last Name field.");
			else if (email_address.search("@") == -1)
				alert("Please fill in a valid Email Address.");
			else
				$.ajax({ url: "enroll", type: "POST", data: {"first_name" : first_name, "last_name" : last_name, "email_address" : email_address},
					error: enroll_error, success: enrolled, dataType: "json", contentType : "application/x-www-form-urlencoded" });
		}
		
		function submit_enrollment(x)
		{
			enroll(x.first_name.value, x.last_name.value, x.email_address.value);
			return false;
		}
		
	</script>
</head>

<body>
	

	<div id="wrap">
<div id="top">
	<h2>C++ Grandmaster Certification</h2>
	<div id="menu">
		<ul>
			<li><a href="index.html">home</a></li>
			<li><a href="http://forum.cppgm.org">forum</a></li>
			<li><a href="about.html">about</a></li>
		</ul>
	</div>
</div>
<div id="content">
	<div id="left">
<h2>CPPGM Programming Assignment 9 (cy86)</h2>

<p>Write a C++ application called <code>cy86</code> that translates a set of source files in the CY86 Mock Intermediate Language (described below) into a native Linux x86-64 program.</p>

<h3>Prerequisites</h3>

<p>You should complete Reading Assignment B before starting this assignment.</p>

<h3>Starter Kit</h3>

<p>The starter kit can be obtained from:</p>

<pre><code>$ git clone git://git.cppgm.org/pa9.git
</code></pre>

<p>It contains:</p>

<ul>
<li>a stub implementation of <code>cy86</code></li>
<li>a compiled reference implementation <code>cy86-ref</code></li>
<li>a test suite of CY86 programs.</li>
<li>the grammar for this assignment called <code>pa9.gram</code></li>
<li>a html grammar explorer of <code>pa9.gram</code> in the sub-directory <code>grammar/</code></li>
<li>a machine readable list of the CY86 operand constraints (described below) called <code>cy86-opcode.desc</code></li>
</ul>

<p>You will want to extend your PA5 <code>preproc</code> solution to complete this assignment.</p>

<h3>Input / Command-Line Arguments</h3>

<p>The same as PA8 <code>nsinit</code>.  Behaviour is undefined unless the command-line arguments match:</p>

<pre><code>$ cy86 -o &lt;outfile&gt; &lt;srcfile1&gt; &lt;srcfile2&gt; ... &lt;srcfileN&gt;
</code></pre>

<p>with the same relaxations as PA8</p>

<h3>Output Format</h3>

<p><code>cy86</code> shall write a Linux x86-64 Program to <code>&lt;outfile&gt;</code>.  A Linux x86-64 Program is an ELF Executable file (details in Reading Assignment B).</p>

<h3>Testing</h3>

<p>Testing has changed for PA9.  It is now based on the output of the generated program of your implementation.</p>

<p>For this assignment your solution will be tested in the following way:</p>

<p>For each test case <code>x</code> your implementations output will be generated as follows:</p>

<p>There are n input translation units <code>x.t.1</code> through <code>x.t.n</code> as per PA8.</p>

<p>Your compiler will be executed on them as follows:</p>

<pre><code>$ cy86 -o x.my.program x.t.*
</code></pre>

<p>The <strong>numeric</strong> exit code (<code>$?</code>) will be stored in <code>x.my.impl.exit_status</code></p>

<p>If the exit code is <code>0</code> (meaning success), the resulting program will then be executed:</p>

<pre><code>$ x.my.program &gt; x.my.program.stdout
</code></pre>

<p>The numeric exit code (<code>$?</code>) will be stored in <code>x.my.program.exit_status</code></p>

<p>The reference implementation output is generated in the same fashion.</p>

<p>If <code>x.ref.impl.exit_status</code> is not the same as <code>x.my.impl.exit_status</code> the test case fails.</p>

<p>Otherwise, if <code>x.ref.impl.exit_status</code> is non-zero (indicating an ill-formed program) the test case passes.</p>

<p>Otherwise, if <code>x.ref.program.stdout</code> is identical to <code>x.my.program.stdout</code> and <code>x.ref.program.exit_status</code> is identical to <code>x.my.program.exit_status</code> the test case passes.</p>

<p>Otherwise, the test case fails.</p>

<h3>CY86 Language Specification</h3>

<h4>Phases of Translation</h4>

<p>The CY86 phases of translation are identical to the C++ phases of translation from 1 to 6 and up to and including the tokenization part of phase 7.  (That is, the C++ preprocessor and tokenizer are applied.)  It is at the parsing phase the two languages diverge.</p>

<p>There are no user-defined literals in CY86, it is an error if one is present.  Although the C++ keywords are reserved in CY86, they are not used.  It is therefore also an error if a C++ keyword is present.</p>

<p>After tokenization, the token sequence from each translation unit is concatenated in the order given on the command-line into one long token sequence.  This token sequence is then matched against the <code>program</code> grammar:</p>

<h4>Grammar/Semantics</h4>

<pre><code>program:
    (statement OP_SEMICOLON)*
</code></pre>

<p>A program consists of a sequence of statements.  Each statement is in one of the following forms:</p>

<pre><code>statement:
    label OP_COLON statement
    opcode operand*
    TT_LITERAL
    OP_MINUS TT_LITERAL

label:
    TT_IDENTIFIER

opcode:
    TT_IDENTIFIER
</code></pre>

<p>A <code>label</code> introduces a name for a 64-bit unsigned long int value that represents the virtual memory address of the labelled <code>statement</code>.  If the spelling of a label is the same as either an opcode, register or another label - the program is ill-formed.  (Note that labels can be forward referenced, so a label may be used before the label is introduced with this construct).</p>

<p>The two literal statement forms place the specified literal data in PA2 encoding, after appropriate zero-padding to achieve the correct alignment.  This allows static data to be introduced into the program (see also the <code>data</code> opcodes).  The <code>OP_MINUS</code> prefix may only be applied to arithmetic types, and specify the arithmetic negation of the value.</p>

<p>An <code>opcode</code> is an identifier.  It specifies one of the CY86 instructions (described below).  This is followed by zero or more operands:</p>

<pre><code>operand:
    register
    immediate
    memory
</code></pre>

<p>The opcode dictates the number of operands, and for each their width and other constraints.  The operands however can be parsed context-free, and later semantic rules can be applied.  (In fact CY86, like many near-assembly-level languages, is a regular language).</p>

<p>Each <code>operand</code> may be either a <code>register</code>, an <code>immediate</code> or a <code>memory</code>.</p>

<p>A <code>register</code> is an identifier with one of the following spellings:</p>

<pre><code>sp
bp
x8
x16
x32
x64
y8
y16
y32
y64
z8
z16
z32
z64
t8
t16
t32
t64
</code></pre>

<p>The CY86 machine has four general-purpose 64-bit registers <code>x64</code>, <code>y64</code>, <code>z64</code> and <code>t64</code> and, like x86-64, these registers have 32-bit, 16-bit and 8-bit aliases to the lower bits:</p>

<pre><code>x8    x16    x32    x64
y8    y16    y32    y64
z8    z16    z32    z64
t8    t16    t32    t64
</code></pre>

<blockquote>
  <p>NOTE: When an instruction writes to x32, it shall zero the upper 32 bits of x64.  Likewise for y32-y64, z32-z64 and t32-t64.  This is to match the behaviour of x86 registers.</p>
</blockquote>

<p>As well as two 64-bit address registers:</p>

<pre><code>sp  bp
</code></pre>

<p>(Note these are not the same as the x86-64 16-bit registers of the same names, sp and bp.  The suggested design has the CY86 sp and bp registers backed by the x86-64 rsp and rbp registers respectively.)</p>

<p>Internally, it also has an unaddressable 64-bit instruction pointer <code>pc</code>.  It has no flag registers.</p>

<p>If a register does not match the required operand width in an instruction, the program is ill-formed.</p>

<p>An <code>immediate</code> operand has one of the following forms:</p>

<pre><code>immediate:
    TT_LITERAL
    label
    OP_LPAREN TT_LITERAL OP_RPAREN
    OP_LPAREN OP_MINUS TT_LITERAL OP_RPAREN
    OP_LPAREN label OP_RPAREN
    OP_LPAREN label OP_PLUS TT_LITERAL OP_RPAREN
    OP_LPAREN label OP_MINUS TT_LITERAL OP_RPAREN
</code></pre>

<p>The parenthesis only serve to delimit the immediate tokens and have no semantic meaning.</p>

<p>The <code>OP_MINUS</code> <code>TT_LITERAL</code> form carries out arithmetic negation as for literal statements described above.</p>

<p>The <code>label</code> <code>OP_PLUS/MINUS</code> <code>TT_LITERAL</code> form requires the literal be of integral type.  The value undergoes negation if <code>OP_MINUS</code> is present.  The value is then sign-extended to 64-bits if a signed type, or zero-extended to 64-bit if unsigned.  The value is then added to the constant value of the label to produce the immediate value.  The final type is unsigned long int.</p>

<p>If the width of a literal (given in PA2) does not match the operand width required by the opcode:</p>

<ul>
<li>If the literal is too long, it is truncated to the required size, by removing the rightmost bytes.</li>
<li>If the literal is too short it shall be sign-extended if it is a signed integral type, or zero-extended otherwise.</li>
</ul>

<p>A <code>memory</code> operand specifies a range of bytes in virtual memory:</p>

<pre><code>memory:
    OP_LSQUARE TT_LITERAL OP_RSQUARE
    OP_LSQUARE register OP_RSQUARE
    OP_LSQUARE register OP_PLUS TT_LITERAL OP_RSQUARE
    OP_LSQUARE register OP_MINUS TT_LITERAL OP_RSQUARE
    OP_LSQUARE label OP_RSQUARE
    OP_LSQUARE label OP_PLUS TT_LITERAL OP_RSQUARE
    OP_LSQUARE label OP_MINUS TT_LITERAL OP_RSQUARE
</code></pre>

<p>The size of the range of bytes is determined by the opcode and operand width.</p>

<p>The address of the first byte is given by the expression inside the square brackets.  The width of the address value is 64-bit, so only 64-bit registers may be used, and labels and <code>TT_LITERAL</code>s are interpreted as described above in the same manner as immediate operands of 64-bit width.</p>

<p>The <em>red zone</em> (the 128 bytes from <code>[sp-128]</code> to <code>[sp-1]</code> inclusive ) is reserved and is undefined in CY86 programs.  (This allows your CY86 implementation to use this area for temporary storage).</p>

<h4>Entry Point</h4>

<p>If there exists a label <code>start</code>, the entry point of a CY86 program is the label <code>start</code>.</p>

<p>Otherwise, the entry point of a CY86 program is the first <code>statement</code> in the <code>program</code>. </p>

<h3>CY86 Opcode Descriptions</h3>

<p>In the following documentation, each opcode descriptor is followed by one or more operand descriptors.  An operand descriptor is a string that is a concatenation of one or more of the following strings:</p>

<pre><code>w  -  written to - may not be an immediate
r  -  read from
a  -  address
b  -  boolean, behaviour is undefined if not equal to 0 or 1
i  -  an integer (either signed or unsigned)
s  -  a signed integer (hi bit is sign bit)
u  -  an unsigned integer (no sign bit)
f  -  a floating point number
I  -  an immediate only
8  -  8 bits wide
16 -  16 bits wide
32 -  32 bits wide
64 -  64 bits wide
80 -  80 bits wide
</code></pre>

<p>For example, in the following hypothetical definition:</p>

<pre><code>foo sr32
</code></pre>

<p>The opcode is <code>foo</code> and it takes one operand.  The operand (<code>sr32</code>) is a signed (<code>s</code>) 32-bit (<code>32</code>) integer (<code>i</code>) that is read from.</p>

<h4>Literal Data</h4>

<pre><code>data8    rI8
data16   rI16
data32   rI32
data64   rI64
</code></pre>

<p>The data instructions are literal encodings of their immediate operands (after appropriate immediate width conversion).  They also must be aligned so are preceeded if necessary by appropriate zero-padding to align them to their size.  They are not intended for execution, and like literal statements, are a way to add static data to a program image.  For example:</p>

<pre><code>foo: data16 0x1122;
bar: data16 0x3344;
</code></pre>

<p>The label <code>foo</code> address will be divisable by 2.  <code>bar</code> is equal to <code>foo+2</code>.  The four bytes in memory starting at address <code>foo</code> are in hex:</p>

<pre><code>22 11 44 33
</code></pre>

<h4>Data Transfer</h4>

<pre><code>move8    w8   r8
move16   w16  r16
move32   w32  r32                 op1 = op2;
move64   w64  r64
move80   w80  r80
</code></pre>

<p>This command simply copies data from the second operand and overwrites the first.</p>

<h4>Control Transfer</h4>

<pre><code>jump     ar64                     pc = op1
jumpif   br8   ar64               if (op1) pc = op1
call ar64                         sp -= 8; *sp = pc; jump op1;
ret                               jump *sp; sp += 8;
</code></pre>

<p>The <code>jump</code> command unconditionally assigns to the <code>pc</code> instruction counter.  The instruction at the given address will be the next executed.</p>

<p>The <code>jumpif</code> command jumps to the address in its second operand, if and only if the first operand is non-zero.</p>

<p>The <code>call</code> command pushes the current <code>pc</code> on the stack and then jumps to op1.</p>

<p>The <code>ret</code> command pops the stack into the <code>pc</code>.</p>

<h4>Bitwise Logic</h4>

<pre><code>not8    w8   r8
not16   w16  r16                 op1 = ~op2
not32   w32  r32 
not64   w64  r64
</code></pre>

<p>Bitwise NOT.</p>

<pre><code>and8    w8   r8   r8
and16   w16  r16  r16            op1 = op2 &amp; op3
and32   w32  r32  r32
and64   w64  r64  r64
</code></pre>

<p>Bitwise AND.</p>

<pre><code>or8     w8   r8   r8
or16    w16  r16  r16
or32    w32  r32  r32            op1 = op2 | op3
or64    w64  r64  r64
</code></pre>

<p>Bitwise OR.</p>

<pre><code>xor8    w8   r8   r8
xor16   w16  r16  r16
xor32   w32  r32  r32            op1 = op2 ^ op3
xor64   w64  r64  r64
</code></pre>

<p>Bitwise XOR.</p>

<h4>Bit Shift</h4>

<pre><code>lshift8     iw8   ir8   ur8
lshift16    iw16  ir16  ur8       op1 = op2 &lt;&lt; op3
lshift32    iw32  ir32  ur8        
lshift64    iw64  ir64  ur8
</code></pre>

<p>Left shift op3 bits.  If op3 is greater than or equal to operand width, behaviour is undefined.  Zero bits are shifted in.</p>

<pre><code>srshift8    sw8   sr8   ur8
srshift16   sw16  sr16  ur8
srshift32   sw32  sr32  ur8
srshift64   sw64  sr64  ur8       op1 = op2 &gt;&gt; op3
urshift8    uw8   ur8   ur8
urshift16   uw16  ur16  ur8
urshift32   uw32  ur32  ur8
urshift64   uw64  ur64  ur8
</code></pre>

<p>Right shift op3 bits.  If op3 is greater than or equal to operand width, behaviour is undefined.  Signed versions preserve sign (shift in copy of previous sign bit).  Unsigned versions shift in zero.</p>

<h4>Floating Conversions</h4>

<pre><code>s8convf80   fw80 sr8
s16convf80  fw80 sr16
s32convf80  fw80 sr32
s64convf80  fw80 sr64
u8convf80   fw80 ur8
u16convf80  fw80 ur16        op1 = (long double) op2
u32convf80  fw80 ur32
u64convf80  fw80 ur64
f32convf80  fw80 fr32
f64convf80  fw80 fr64
</code></pre>

<p>Convert from integer and floating types to 80-bit float.</p>

<pre><code>f80convs8   sw8  fr80
f80convs16  sw16 fr80
f80convs32  sw32 fr80
f80convs64  sw64 fr80
f80convu8   uw8  fr80
f80convu16  uw16  fr80              op1 = (T) op2              
f80convu32  uw32  fr80
f80convu64  uw64  fr80
f80convf32  fw32 fr80
f80convf64  fw64 fr80
</code></pre>

<p>Convert from 80-bit float to integer or floating type.  Behaviour is undefined if the value cannot be exactly represented.</p>

<h4>Arithmatic</h4>

<pre><code>iadd8    iw8   ir8   ir8
iadd16   iw16  ir16  ir16
iadd32   iw32  ir32  ir32
iadd64   iw64  ir64  ir64         op1 = op2 + op3
fadd32   fw32  fr32  fr32
fadd64   fw64  fr64  fr64
fadd80   fw80  fr80  fr80
</code></pre>

<p>Arithmetic addition.  Integer and floating versions. (Note that signed and unsigned integer addition are the same operation).</p>

<pre><code>isub8   iw8   ir8   ir8
isub16  iw16  ir16  ir16
isub32  iw32  ir32  ir32
isub64  iw64  ir64  ir64          op1 = op2 - op3
fsub32  fw32  fr32  fr32
fsub64  fw64  fr64  fr64
fsub80  fw80  fr80  fr80
</code></pre>

<p>Arithmetic subtraction.  Integer and floating versions.  (Note that signed and unsigned integer subtraction are the same operation).</p>

<pre><code>smul8   sw8   sr8   sr8
smul16  sw16  sr16  sr16
smul32  sw32  sr32  sr32
smul64  sw64  sr64  sr64
umul8   uw8   ur8   ur8
umul16  uw16  ur16  ur16          op1 = op2 * op3
umul32  uw32  ur32  ur32
umul64  uw64  ur64  ur64
fmul32  fw32  fr32  fr32
fmul64  fw64  fr64  fr64
fmul80  fw80  fr80  fr80
</code></pre>

<p>Arithmetic multiplication.  Signed integer, unsigned integer and floating-point versions.</p>

<pre><code>sdiv8   sw8   sr8   sr8
sdiv16  sw16  sr16  sr16
sdiv32  sw32  sr32  sr32
sdiv64  sw64  sr64  sr64
udiv8   uw8   ur8   ur8
udiv16  uw16  ur16  ur16          op1 = op2 / op3
udiv32  uw32  ur32  ur32
udiv64  uw64  ur64  ur64
fdiv32  fw32  fr32  fr32
fdiv64  fw64  fr64  fr64
fdiv80  fw80  fr80  fr80
</code></pre>

<p>Arithmetic division.  Signed integer, unsigned integer and floating-point versions.</p>

<pre><code>smod8    sw8   sr8   sr8
smod16   sw16  sr16  sr16
smod32   sw32  sr32  sr32
smod64   sw64  sr64  sr64         op1 = op2 % op3
umod8    uw8   ur8   ur8
umod16   uw16  ur16  ur16
umod32   uw32  ur32  ur32
umod64   uw64  ur64  ur64
</code></pre>

<p>Modulus operation.  Signed integer and unsigned integer versions.</p>

<h4>Comparisons</h4>

<p>In all comparison operations the first 8-bit operand is set to 0x01 to indicate true and 0x00 to indicate false.</p>

<pre><code>ieq8    wb8  ir8  ir8
ieq16   wb8  ir16 ir16
ieq32   wb8  ir32 ir32
ieq64   wb8  ir64 ir64           op1 = op2 == op3
feq32   wb8  fr32 fr32
feq64   wb8  fr64 fr64
feq80   wb8  fr80 fr80
</code></pre>

<p>Equals operation.  Integer (bitwise) and floating versions.</p>

<pre><code>ine8    wb8  ir8  ir8
ine16   wb8  ir16 ir16
ine32   wb8  ir32 ir32 
ine64   wb8  ir64 ir64           op1 = op2 != op3
fne32   wb8  fr32 fr32
fne64   wb8  fr64 fr64
fne80   wb8  fr80 fr80
</code></pre>

<p>Not Equals operation.  Integer (bitwise) and floating versions.</p>

<pre><code>slt8    wb8  sr8  sr8
slt16   wb8  sr16 sr16
slt32   wb8  sr32 sr32
slt64   wb8  sr64 sr64
ult8    wb8  ur8  ur8
ult16   wb8  ur16 ur16            op1 = op2 &lt; op3
ult32   wb8  ur32 ur32
ult64   wb8  ur64 ur64
flt32   wb8  fr32 fr32
flt64   wb8  fr64 fr64
flt80   wb8  fr80 fr80
</code></pre>

<p>Less Than operation.  Signed integer, unsigned integer and floating versions.</p>

<pre><code>sgt8    wb8  sr8  sr8
sgt16   wb8  sr16 sr16
sgt32   wb8  sr32 sr32
sgt64   wb8  sr64 sr64
ugt8    wb8  ur8  ur8
ugt16   wb8  ur16 ur16            op1 = op2 &gt; op3
ugt32   wb8  ur32 ur32
ugt64   wb8  ur64 ur64
fgt32   wb8  fr32 fr32
fgt64   wb8  fr64 fr64
fgt80   wb8  fr80 fr80
</code></pre>

<p>Greater Than operation.  Signed integer, unsigned integer and floating versions.</p>

<pre><code>sle8    wb8  sr8  sr8
sle16   wb8  sr16 sr16
sle32   wb8  sr32 sr32
sle64   wb8  sr64 sr64
ule8    wb8  ur8  ur8
ule16   wb8  ur16 ur16            op1 = op2 &lt;= op3
ule32   wb8  ur32 ur32
ule64   wb8  ur64 ur64
fle32   wb8  fr32 fr32
fle64   wb8  fr64 fr64
fle80   wb8  fr80 fr80
</code></pre>

<p>Less than or Equal operation.  Signed integer, unsigned integer and floating versions.</p>

<pre><code>sge8    wb8  sr8  sr8
sge16   wb8  sr16 sr16
sge32   wb8  sr32 sr32
sge64   wb8  sr64 sr64
uge8    wb8  ur8  ur8
uge16   wb8  ur16 ur16            op1 = op2 &gt;= op3
uge32   wb8  ur32 ur32
uge64   wb8  ur64 ur64
fge32   wb8  fr32 fr32
fge64   wb8  fr64 fr64
fge80   wb8  fr80 fr80
</code></pre>

<p>Greater than or Equal operation.  Signed integer, unsigned integer and floating versions.</p>

<h4>System Calls</h4>

<pre><code>syscall0  w64 r64
syscall1  w64 r64 r64
syscall2  w64 r64 r64 r64
syscall3  w64 r64 r64 r64 r64                op1 = syscall(op2, ..., opn)
syscall4  w64 r64 r64 r64 r64 r64
syscall5  w64 r64 r64 r64 r64 r64 r64
syscall6  w64 r64 r64 r64 r64 r64 r64 r64
</code></pre>

<p>The number after the opcode is the number of parameters to the system call.  op1 stores the return value.  op2 is the system call number.  op3 through to op3+n are the parameters to the system call.</p>

<h3>Design Notes (optional)</h3>

<p>The primary purpose of this assignment and the CY86 language is to provide a simple wrapper for you to write and test your x86-64 Assembler component.</p>

<p>The recommended PA9 solution design is as follows:</p>

<pre><code>PA5Preproc
   |
   | Tokens            (eg TT_IDENTIFIER)
   v
CY86Parser
   |
   | CY86Instructions  (eg move64 x64 y64)
   v
CY86ToX86Translator
   |
   | X86Instructions   (eg mov r12 r13)
   v
X86Assembler
   |
   | X86MachineCode    (eg 4D 89 EC)
   v
X86Program
</code></pre>

<p>For later assignments you will then reuse and extend your X86Instruction and X86Assembler components in the final stages of your real backend.</p>

<p>As you will discover the CY86Parser and CY86ToX86Translator components are small and just for testing.  In particular, the CY86 language is not intended to be an intermediate form used in PA10 and future assignments.  You may decide later to extend the CY86 language to serve as an intermediate form in your future designs, but this is not required or recommended.</p>

<p>The CY86Parser is a very simplified version of a parser like the one you wrote for PA6.  The CY86 language has only eight non-terminals and is a regular language so this will be trivial.  As output from your CY86Parser you will want to have a sequence of CY86Instructions that form an object model of the various CY86 opcodes and operands.  You can use the usual object-oriented techniques to model the different kinds of operands and their association with the instruction that contains them.</p>

<p>You will also want to perform a short semantic analysis phase to tie up labels and to check operand type and transform operand widths and so on.</p>

<p>The next step is to plan out which x86 instructions you will want to use to translate CY86 into, and how you will use registers/memory.  Each CY86 instruction can be translated into a short fixed finite sequence of x86 instructions.  There are multiple ways to do this, but as a recommended simple design we suggest the following:</p>

<p>You can directly back the CY86 registers with x86 registers as follows:</p>

<pre><code>cy86    x86
----    ---
sp      rsp
bp      rbp
x64     r12
y64     r13
z64     r14
t64     r15
</code></pre>

<p>The stack register and base register are obvious.  The reason r12 to r15 are recommended for the other registers is that they are not used for anything else in other x86 instructions or in system calls, so this is conveniant as they are never clobbered.</p>

<p>Then to translate a CY86 instructions you can use the other x86 registers freely.  Generally speaking the way we recommend to translate a non-floating-point CY86 instruction is as follows:</p>

<ol>
<li>load the input operands into some fixed x86 registers for the instruction (like rax, rbx, etc)</li>
<li>execute x86 instructions on those fixed x86 registers to a fixed x86 output register</li>
<li>store the write operand from the set x86 output register to the cy86 output operand</li>
</ol>

<p>For x87 floating point operations this is similiar but you can use the x87 register stack:</p>

<ol>
<li>push the cy86 input operands onto the x87 floating stack</li>
<li>execute the x87 floating point instruction</li>
<li>pop the x87 floating stack into the cy86 output operand</li>
</ol>

<p>If you need a temporary memory operand (as you may for some floating point instructions) you can use the <em>red zone</em>, this is the area just logically above / numerically below the stack pointer.  For example the eight bytes at <code>[rsp-8]</code> are in the red zone.  Be careful with instructions that modify the cy86 <code>sp</code> register and the use of the red zone.</p>

<p>As you will have learned in Reading Assignment B, x86 instructions are classified first by a mneumonic (each of which has its own page in the Intel manual), and for every mneumonic there are several forms.  You will only need to use a subset of the mneumonics and for each only a subset of their forms.</p>

<p>As a hint, here are most of the x86 instructions that <code>cy86-ref</code> uses:</p>

<pre><code>MOV AND OR XOR ADD SUB CMP
FADDP FSUBP FMULP FDIVP FCOMIP
SYSCALL SETcc NOT SHL SHR SAR
MUL IMUL DIV IDIV JMP Jcc
FILD FLD FISTP FSTP
</code></pre>

<p>And for each mneumonic only a subset of the forms are used.  You may want to use these or additional/different ones.</p>

<p>Once you have determined which mneumonics and forms of those mneumonics you will need you should then work through the pages for them in the Intel manual.  Figure out their semantics and then transcribe the forms into C++ data structures.  You will quickly notice that many instructions use similar patterns, and you can create an abstract base for those instructions that share properties.</p>

<p>You should keep in mind that you may want to extend your x86 assembler later with more instructions, so you should structure it in such a way as to make it easy to extend.</p>

<p>Like for CY86 operands, you will want to develop an object model for x86 operands.  They have a similar structure (immediates, registers, memory addresses), but x86 has more addressing forms (like scale-index-base <code>[rax+rcx*8+42]</code>).  You don't need to support them all internally, but can if you wish.</p>

<p>Once you have your x86 instructions and x86 operands in an object model you will then need to write your x86 machine code generator.  In general an x86 instruction can have prefixes, like operand size prefixes, a REX byte with REX.W, REX.R, REX.X and REX.B bits, some number of opcode bytes, a modr/m byte with reg, mod and rm fields, and a sib byte with scale, index, base fields, and displacement and immediate byte sequences.  All of those parts apart from the opcode byte may be (and usually are) absent from an instruction.  You will want to create a data structure to represent an x86 machine code instruction in full generality, and then write a function that converts from your X86Instruction object model to that data structure.  From the data structure you will then write a function that creates an array of bytes that is the final machine code.</p>

<p>Because final label values will depend on the byte size of instructions, and in general this is not known until the machine code is generated, you will need to incorporate a way to relocate the values as per your PA8 linker.  One way to do this is to assemble some marker value into the immediate, storing its location separately, and then making another pass of the machine code to patch them.  There is some discussion about this and related techniques around section 6.7 of the dragon book.</p>

<p>It is helpful in selecting instructions, and also to check your assembler, to compare it against a production toolchain.  The best way to see what, for example, gcc uses to implement an instruction is to create a test translation unit and then decompile.</p>

<p>For example, let's find out what instructions gcc uses to add two long doubles:</p>

<pre><code>void f(long double* res, long double* op1, long double* op2)
{
    *res = *op1 + *op2;
}
</code></pre>

<p>Compile this with:</p>

<pre><code>$ gcc -c -O3 test.c
</code></pre>

<p>And then use:</p>

<pre><code>$ objdump -d -M intel test.o
</code></pre>

<p>The <code>-M intel</code> switch will give you intel syntax, which is much clearer for human-reading and will match up better with what you read in the Intel manual.</p>

<p>The objdump gives us:</p>

<pre><code>0:  db 2e                   fld    TBYTE PTR [rsi]
2:  db 2a                   fld    TBYTE PTR [rdx]
4:  de c1                   faddp  st(1),st
6:  db 3f                   fstp   TBYTE PTR [rdi]
8:  c3                      ret
</code></pre>

<p>So we can see the pointers are passed in <code>rdi</code>, <code>rsi</code> and <code>rdx</code>.  The first two FLD instructions load from the memory addresses <code>[rsi]</code> and <code>[rdi]</code> onto the x87 FPU register stack.  The FADDP instructions adds the two top values.  The FSTP then stores the result to the memory address.  The type TBYTE is for 10 bytes or 80 bits.  The prefix <code>TBYTE PTR</code> explicitly states the operand size.  If the assembler can determine this from the context this prefix can be omitted.</p>

<p>To compare your x86 instruction to machine code translator to a production assembler you can use a gas input file like this:</p>

<pre><code>.intel_syntax noprefix
.global _start
_start:
    XXX
</code></pre>

<p>Where XXX is the instruction in Intel syntax.  For example:</p>

<pre><code>.intel_syntax noprefix
.global _start
_start:
    mov eax, [rbx]
</code></pre>

<p>Save this to <code>test.s</code> and then execute:</p>

<pre><code>$ gcc -nostdlib test.s
$ objdump -d -M intel a.out
</code></pre>

<p>You will see the machine code for your instruction:</p>

<pre><code>4000d4: 8b 03                   mov    eax,DWORD PTR [rbx]
</code></pre>

<p>The machine code is on the left, hex <code>8B 03</code>.</p>

<p>Notice that the assembler has automatically added the unnecessary <code>DWORD PTR</code> prefix to the memory operand. <code>DWORD</code> in Intel syntax is 32-bits (1 byte = BYTE, 2 bytes = WORD, 4 bytes = DWORD (doubleword), 8 bytes = QWORD (quadword), 10 bytes = TBYTE).   The operand size was infered from the use of the <code>eax</code> register which is 32-bits.</p>

<p>Here are some useful GDB commands to work with raw programs at the bare metal machine-code level:</p>

<pre><code>$ readelf -a myprogram
Entry Point Address: 0x400123
$ gdb ./myprogram
gdb&gt; break *0x400123                   &lt;--- set breakpoint at address 0x400123
gdb&gt; run &lt; test.stdin
breakpoint hit
gdb&gt; set disassembly-flavor intel      &lt;--- intel syntax
gdb&gt; x/20i $pc                         &lt;--- disassemble current and following 20 instructions
gdb&gt; stepi                             &lt;--- step one instruction
gdb&gt; info registers                    &lt;--- the x86 general purpose register values
gdb&gt; info all-registers                &lt;--- all registers, including x87 registers
gdb&gt; print $rax                        &lt;--- print value of rax register
</code></pre>

<p>The Examining Memory page of the GDB manual is very useful: <a href="https://sourceware.org/gdb/onlinedocs/gdb/Memory.html">https://sourceware.org/gdb/onlinedocs/gdb/Memory.html</a>, as is the rest of the manual.</p>

	</div>

			<div id="right">
				<div id="nav">
					<img src="img/cppgm.png" alt="logos"></img>
					<h3>Current Class Running</h3>
					<h3>Enrollments Closed</h3>
					<h3>Next Class Starts: TBD</h3>
					<h3><a href="preregister.html">Pre-Register Now</a></h3>
				</div>
				<!--
				<div class="box">
					<div class="boxinset">
						<form action="enroll" method="POST" onsubmit="return submit_enrollment(this);" >
							<table style="width: 100%">
								<tr>
									<td><b>First Name:</b></td>
									<td><input style="width: 100%" type="text" name="first_name"></input></td>
								</tr>
								<tr>
									<td><b>Last Name:</b></td>
									<td><input style="width: 100%" type="text" name="last_name"></input></td>
								</tr>
								<tr>
									<td><b>Email:</b></td>
									<td><input style="width: 100%" type="text" name="email_address"></input></td>
								</tr>
								<tr>
									<td>&nbsp;</td>
									<td align="right"><input
										style="background-color: #a2c134; color: #303030; font-size: 18px;"
										type="submit" id="enroll_button" value="Enroll In Class"></input></td>
								</tr>
							</table>
						</form>
					</div>
				</div>
				-->

				<img style="margin-top: 20px;" src="img/toolchain-architecture.gif" alt="architecture diagram"></img>
				
				<div id="nav">
				<h3>C++ Standard Library</h3>
				<table>
				<tr><td style="padding:10px">
				<ul>
				<li>Language Support</li>
				<li>Diagnostics</li>
				<li>General Utilities</li>
				<li>Strings</li>
				<li>Localization</li>
				<li>Containers</li>
				<li>Iterators</li>
				</ul>
				</td><td style="padding:10px">
				<ul>
				<li>Algorithms</li>
				<li>Numerics</li>
				<li>Input/Ouput</li>
				<li>Regular Expressions</li>
				<li>Atomics</li>
				<li>Thread Support</li>
				<li>C Library</li>
				</ul>
				
				</td></tr>
				</table>
				</div>
			</div>
			<div id="clear"></div>
		</div>
		<div id="footer">
			<p>
				&copy; 2013 CPPGM Foundation - <a href="http://www.cppgm.org">www.cppgm.org</a>.
			</p>
		</div>
	</div>
</body>
</html>
